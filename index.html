<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pagina para mi coshita emosa luz marina</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Configuración de la Escena
        const scene = new THREE.Scene();

        // 2. Configuración de la Cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);

        // 3. Configuración del Renderizador
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 4. Crear el Skybox (Fondo Estrellado)
        const textureCubeLoader = new THREE.CubeTextureLoader();
        const spaceTexture = textureCubeLoader.load([
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_px.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nx.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_py.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_ny.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_pz.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nz.jpg'
        ]);
        scene.background = spaceTexture;

        // 5. Crear el Agujero Negro "real" (esfera que absorbe luz)
        const blackHoleGeometry = new THREE.SphereGeometry(1.0, 64, 64);
        const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleCore = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
        scene.add(blackHoleCore);

        // 6. Crear el Disco de Acreción (un anillo plano)
        const accretionDiskGeometry = new THREE.RingGeometry(1.5, 2.5, 64);
        const accretionDiskMaterial = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/lava/cloud.png'),
            color: 0xffa000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(accretionDiskGeometry, accretionDiskMaterial);
        accretionDisk.rotation.x = Math.PI / 2;
        accretionDisk.rotation.z = Math.PI / 4;
        scene.add(accretionDisk);

        // 7. Implementar el efecto de Lente Gravitacional con ShaderMaterial
        const distortionGeometry = new THREE.SphereGeometry(1.2, 64, 64);
        const distortionMaterial = new THREE.ShaderMaterial({
            uniforms: {
                cubeTexture: { value: spaceTexture },
                cameraPosition: { value: camera.position },
                blackHolePosition: { value: blackHoleCore.position },
                blackHoleRadius: { value: blackHoleCore.geometry.parameters.radius * 1.5 }
            },
            vertexShader: `
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform samplerCube cubeTexture;
                uniform vec3 cameraPosition;
                uniform vec3 blackHolePosition;
                uniform float blackHoleRadius;

                void main() {
                    vec3 rayDir = normalize(gl_FragCoord.xyz - vec3(cameraPosition.x, cameraPosition.y, cameraPosition.z));
                    vec3 spherePos = blackHolePosition;
                    float radius = blackHoleRadius;

                    vec3 lookupVector;
                    vec3 oc = cameraPosition - spherePos;
                    float a = dot(rayDir, rayDir);
                    float b = 2.0 * dot(oc, rayDir);
                    float c = dot(oc, oc) - radius * radius;
                    float discriminant = b * b - 4.0 * a * c;

                    if (discriminant >= 0.0) {
                        float t = (-b + sqrt(discriminant)) / (2.0 * a);
                        vec3 intersectionPoint = cameraPosition + rayDir * t;
                        vec3 normal = normalize(intersectionPoint - spherePos);
                        lookupVector = reflect(rayDir, normal) * 0.9;
                    } else {
                        lookupVector = rayDir;
                    }

                    gl_FragColor = textureCube(cubeTexture, lookupVector);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.NoBlending,
        });
        const distortionSphere = new THREE.Mesh(distortionGeometry, distortionMaterial);
        scene.add(distortionSphere);

        // 8. Luces
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // 9. Controles de Órbita
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.panSpeed = 0.5;
        controls.minDistance = 2;
        controls.maxDistance = 50;

        // --- INICIO: Añadir textos flotantes ---

        const texts = [
            "mi niña linda❤️",
            "Mi corazón 🥰",
            "Mi Reyna 👑",
            "Dueña de mi corazón ❤️",
            "Mi bb 😘",
            "Luz ❤️",
            "Te amo 🌹",
            "Te adoro🌷",
            "Marina te amo 💝",
            "Coshita emosa💝💝💝",
            "Mi luz 💫",
            "Para ti 💖",
            "Mi goldita 😚",
            "Chiquita linda 😘😍"
        ];

        const textSprites = [];

        function createTextSprite(message, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 64;
            const padding = 10;
            const font = `bold ${fontSize}px Arial`;

            context.font = font;
            const metrics = context.measureText(message);
            canvas.width = metrics.width + padding * 2;
            canvas.height = fontSize + padding * 2;

            context.font = font;
            context.fillStyle = 'rgba(0, 0, 0, 0.0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#FFFFFF';
            context.textBaseline = 'middle';
            context.textAlign = 'center';
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, blending: THREE.AdditiveBlending });
            const sprite = new THREE.Sprite(material);

            const aspect = canvas.width / canvas.height;
            const spriteHeight = 1;
            sprite.scale.set(spriteHeight * aspect, spriteHeight, 1);

            sprite.position.set(x, y, z);
            scene.add(sprite);
            return sprite;
        }

        const numTexts = texts.length;
        const spawnRadius = 15;
        const spawnHeight = 5;
        const textsFloatAmplitude = 0.5;

        texts.forEach((text, index) => {
            const angle = (index / numTexts) * Math.PI * 2;
            const x = Math.cos(angle) * spawnRadius * (0.8 + Math.random() * 0.4);
            const z = Math.sin(angle) * spawnRadius * (0.8 + Math.random() * 0.4);
            const y = (Math.random() - 0.5) * spawnHeight * 2;
            const sprite = createTextSprite(text, x, y, z);
            sprite.originalY = y;
            sprite.speedOffset = Math.random() * Math.PI * 2;
            textSprites.push(sprite);
        });

        // --- FIN: Añadir textos flotantes ---

        // 10. Animación y Bucle de Renderizado
        function animate() {
            requestAnimationFrame(animate);

            blackHoleCore.rotation.y += 0.001;
            accretionDisk.rotation.z += 0.003;
            accretionDisk.rotation.x += 0.0005;

            distortionMaterial.uniforms.cameraPosition.value.copy(camera.position);

            const time = performance.now() * 0.001;
            textSprites.forEach(sprite => {
                sprite.position.y = sprite.originalY + Math.sin(time * 0.5 + sprite.speedOffset) * textsFloatAmplitude;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 11. Manejar el redimensionamiento de la ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
