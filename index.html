<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pagina para mi coshita emosa luz marina</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
          }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // 1. Configuraci贸n de la Escena
        const scene = new THREE.Scene();

        // 2. Configuraci贸n de la C谩mara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10);

        // 3. Configuraci贸n del Renderizador
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 4. Crear el Skybox (Fondo Estrellado)
        const textureCubeLoader = new THREE.CubeTextureLoader();
        const spaceTexture = textureCubeLoader.load([
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_px.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nx.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_py.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_ny.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_pz.jpg',
            'https://threejs.org/examples/textures/cube/MilkyWay/dark-s_nz.jpg'
        ]);
        scene.background = spaceTexture;

        // 5. Crear el Agujero Negro "real" (esfera que absorbe luz)
        const blackHoleGeometry = new THREE.SphereGeometry(1.0, 64, 64);
        const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHoleCore = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
        scene.add(blackHoleCore);

        // 6. Crear el Disco de Acreci贸n (un anillo plano)
        const accretionDiskGeometry = new THREE.RingGeometry(1.5, 2.5, 64);
        const accretionDiskMaterial = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/lava/cloud.png'),
            color: 0xffa000,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        const accretionDisk = new THREE.Mesh(accretionDiskGeometry, accretionDiskMaterial);
        accretionDisk.rotation.x = Math.PI / 2;
        accretionDisk.rotation.z = Math.PI / 4;
        scene.add(accretionDisk);

        // 7. Implementar el efecto de Lente Gravitacional con ShaderMaterial
        const distortionGeometry = new THREE.SphereGeometry(1.2, 64, 64);
        const distortionMaterial = new THREE.ShaderMaterial({
            uniforms: {
                cubeTexture: { value: spaceTexture },
                cameraPosition: { value: camera.position },
                blackHolePosition: { value: blackHoleCore.position },
                blackHoleRadius: { value: blackHoleCore.geometry.parameters.radius * 1.5 }
            },
            vertexShader: `
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform samplerCube cubeTexture;
                uniform vec3 cameraPosition;
                uniform vec3 blackHolePosition;
                uniform float blackHoleRadius;

                void main() {
                    vec3 rayDir = normalize(gl_FragCoord.xyz - vec3(cameraPosition.x, cameraPosition.y, cameraPosition.z));
                    vec3 spherePos = blackHolePosition;
                    float radius = blackHoleRadius;

                    vec3 lookupVector;
                    vec3 oc = cameraPosition - spherePos;
                    float a = dot(rayDir, rayDir);
                    float b = 2.0 * dot(oc, rayDir);
                    float c = dot(oc, oc) - radius * radius;
                    float discriminant = b * b - 4.0 * a * c;

                    if (discriminant >= 0.0) {
                        float t = (-b + sqrt(discriminant)) / (2.0 * a);
                        vec3 intersectionPoint = cameraPosition + rayDir * t;
                        vec3 normal = normalize(intersectionPoint - spherePos);
                        lookupVector = reflect(rayDir, normal) * 0.9;
                    } else {
                        lookupVector = rayDir;
                    }

                    gl_FragColor = textureCube(cubeTexture, lookupVector);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.NoBlending,
        });
        const distortionSphere = new THREE.Mesh(distortionGeometry, distortionMaterial);
        scene.add(distortionSphere);

        // 8. Luces
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // 9. Controles de rbita
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.panSpeed = 0.5;
        controls.minDistance = 2;
        controls.maxDistance = 50;

        // --- INICIO: A帽adir textos flotantes ---

        const texts = [
            "mi ni帽a lindaわ",
            "Mi coraz贸n グ",
            "Mi Reyna ",
            "Due帽a de mi coraz贸n わ",
            "Mi bb ",
            "Luz わ",
            "Te amo ",
            "Te adoro",
            "Marina te amo ",
            "Coshita emosa",
            "Mi luz ",
            "Para ti ",
            "Mi goldita ",
            "Chiquita linda "
        ];

        const textSprites = [];

        function createTextSprite(message, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 64;
            const padding = 10;
            const font = `bold ${fontSize}px Arial`;

            context.font = font;
            const metrics = context.measureText(message);
            canvas.width = metrics.width + padding * 2;
            canvas.height = fontSize + padding * 2;

            context.font = font;
            context.fillStyle = 'rgba(0, 0, 0, 0.0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = '#FFFFFF';
            context.textBaseline = 'middle';
            context.textAlign = 'center';
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const material = new THREE.SpriteMaterial({ map: texture, transparent: true, blending: THREE.AdditiveBlending });
            const sprite = new THREE.Sprite(material);

            const aspect = canvas.width / canvas.height;
            const spriteHeight = 1;
            sprite.scale.set(spriteHeight * aspect, spriteHeight, 1);

            sprite.position.set(x, y, z);
            scene.add(sprite);
            return sprite;
        }

        const numTexts = texts.length;
        const spawnRadius = 15;
        const spawnHeight = 5;
        const textsFloatAmplitude = 0.5;

        texts.forEach((text, index) => {
            const angle = (index / numTexts) * Math.PI * 2;
            const x = Math.cos(angle) * spawnRadius * (0.8 + Math.random() * 0.4);
            const z = Math.sin(angle) * spawnRadius * (0.8 + Math.random() * 0.4);
            const y = (Math.random() - 0.5) * spawnHeight * 2;
            const sprite = createTextSprite(text, x, y, z);
            sprite.originalY = y;
            sprite.speedOffset = Math.random() * Math.PI * 2;
            textSprites.push(sprite);
        });

        // --- FIN: A帽adir textos flotantes ---

        // 10. Animaci贸n y Bucle de Renderizado
        function animate() {
            requestAnimationFrame(animate);

            blackHoleCore.rotation.y += 0.001;
            accretionDisk.rotation.z += 0.003;
            accretionDisk.rotation.x += 0.0005;

            distortionMaterial.uniforms.cameraPosition.value.copy(camera.position);

            const time = performance.now() * 0.001;
            textSprites.forEach(sprite => {
                sprite.position.y = sprite.originalY + Math.sin(time * 0.5 + sprite.speedOffset) * textsFloatAmplitude;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 11. Manejar el redimensionamiento de la ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
